{"version":3,"file":"type-route.cjs.production.min.js","sources":["../src/asArray.ts","../src/buildPathDefs.ts","../src/getParamDefsOfType.ts","../src/createLocation.ts","../src/noMatch.ts","../src/stringUtils.ts","../src/getPathMatch.ts","../src/getObjectMatch.ts","../src/createMatcher.ts","../src/getQueryMatch.ts","../src/getStateMatch.ts","../src/preventDefaultLinkClickBehavior.ts","../src/buildRoute.ts","../src/createRouteBuilder.ts","../src/createQueryStringSerializer.ts","../src/getMatchingRoute.ts","../src/convertToRouterLocationFromHistoryLocation.ts","../src/getRouteByHref.ts","../src/createNavigationHandlerManager.ts","../src/attemptScrollToTop.ts","../src/serializeStateParams.ts","../src/createRouter.ts","../src/defineRoute.ts","../src/param.ts","../src/createGroup.ts"],"sourcesContent":["export function asArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport {\n  PathParamDef,\n  NamedPathParamDef,\n  BuildPathDefErrorContext,\n  GetRawPath,\n  PathDef,\n  ParamIdCollection,\n} from \"./types\";\nimport { asArray } from \"./asArray\";\nimport { assert } from \"./assert\";\n\nexport function buildPathDefs(\n  routeName: string,\n  pathParamDefCollection: Record<string, PathParamDef>,\n  getRawPath: GetRawPath\n): PathDef[] {\n  const namedPathParamDefs = Object.keys(pathParamDefCollection).map(\n    (paramName) => {\n      const namedPathParameterDefinition: NamedPathParamDef = {\n        paramName,\n        ...pathParamDefCollection[paramName],\n      };\n\n      return namedPathParameterDefinition;\n    }\n  );\n\n  const paramIdCollection: ParamIdCollection = {};\n\n  namedPathParamDefs.forEach(({ paramName }) => {\n    if (__DEV__) {\n      if (\n        paramName.indexOf(\"$\") >= 0 ||\n        paramName.indexOf(\"{\") >= 0 ||\n        paramName.indexOf(\"}\") >= 0 ||\n        paramName.indexOf(\"/\") >= 0\n      ) {\n        throw TypeRouteError.Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character.create(\n          routeName,\n          paramName\n        );\n      }\n    }\n\n    paramIdCollection[paramName] = getParamId(paramName);\n  });\n\n  const rawPath = getRawPath(paramIdCollection);\n\n  if (__DEV__) {\n    if (Array.isArray(rawPath)) {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.arrayOfType(\"string\", \"path\", rawPath),\n        assert.arrayLength(rawPath, 1, Infinity),\n      ]);\n    } else {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.type(\"string\", \"path\", rawPath),\n      ]);\n    }\n  }\n\n  return asArray(rawPath).map((rawPath) => {\n    const errorContext: BuildPathDefErrorContext = {\n      rawPath,\n      routeName,\n    };\n\n    if (__DEV__) {\n      if (rawPath.length === 0) {\n        throw TypeRouteError.Path_may_not_be_an_empty_string.create(\n          errorContext\n        );\n      }\n\n      if (rawPath[0] !== \"/\") {\n        throw TypeRouteError.Path_must_start_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    if (rawPath.length === 1) {\n      return [];\n    }\n\n    if (__DEV__) {\n      if (rawPath.length > 0 && rawPath[rawPath.length - 1] === \"/\") {\n        throw TypeRouteError.Path_may_not_end_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    const rawPathSegments = rawPath.split(\"/\").slice(1);\n\n    const usedPathParams: Record<string, true> = {};\n    const pathDef: PathDef = [];\n\n    for (const rawSegment of rawPathSegments) {\n      if (__DEV__) {\n        if (rawSegment.length === 0) {\n          throw TypeRouteError.Path_may_not_include_empty_segments.create(\n            errorContext\n          );\n        }\n      }\n\n      let includedParamDef: NamedPathParamDef<unknown> | null = null;\n\n      for (const paramDef of namedPathParamDefs) {\n        if (rawSegment.indexOf(getParamId(paramDef.paramName)) >= 0) {\n          if (__DEV__) {\n            if (includedParamDef !== null) {\n              throw TypeRouteError.Path_may_have_at_most_one_parameter_per_segment.create(\n                errorContext,\n                [paramDef.paramName, includedParamDef.paramName]\n              );\n            }\n\n            if (usedPathParams[paramDef.paramName]) {\n              throw TypeRouteError.Path_parameters_may_not_be_used_more_than_once_when_building_a_path.create(\n                errorContext,\n                paramDef.paramName\n              );\n            }\n          }\n\n          includedParamDef = paramDef;\n          usedPathParams[paramDef.paramName] = true;\n        }\n      }\n\n      if (includedParamDef) {\n        const [leading, trailing] = rawSegment.split(\n          getParamId(includedParamDef.paramName)\n        );\n\n        if (__DEV__) {\n          if (\n            encodeURIComponent(leading) !== leading ||\n            encodeURIComponent(trailing) !== trailing\n          ) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              {\n                leading,\n                paramId: getParamId(includedParamDef.paramName),\n                trailing,\n              }\n            );\n          }\n\n          if (\n            includedParamDef[\"~internal\"].optional &&\n            (leading !== \"\" || trailing !== \"\")\n          ) {\n            throw TypeRouteError.Optional_path_parameters_may_not_have_any_text_around_the_parameter.create(\n              errorContext,\n              includedParamDef.paramName,\n              leading,\n              trailing\n            );\n          }\n        }\n\n        pathDef.push({\n          leading,\n          trailing,\n          namedParamDef: includedParamDef,\n        });\n      } else {\n        if (__DEV__) {\n          if (encodeURIComponent(rawSegment) !== rawSegment) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              { leading: rawSegment }\n            );\n          }\n        }\n\n        pathDef.push({\n          leading: rawSegment,\n          trailing: \"\",\n          namedParamDef: null,\n        });\n      }\n    }\n\n    const numOptionalOrTrailingParams = pathDef.filter(\n      (part) =>\n        part.namedParamDef?.[\"~internal\"].optional ||\n        part.namedParamDef?.[\"~internal\"].trailing\n    ).length;\n\n    if (__DEV__) {\n      if (numOptionalOrTrailingParams > 1) {\n        throw TypeRouteError.Path_may_have_at_most_one_optional_or_trailing_parameter.create(\n          errorContext,\n          numOptionalOrTrailingParams\n        );\n      }\n    }\n\n    const lastPathSegmentParameterDefinition =\n      pathDef[pathDef.length - 1].namedParamDef;\n\n    if (__DEV__) {\n      if (\n        numOptionalOrTrailingParams === 1 &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].optional &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].trailing\n      ) {\n        throw TypeRouteError.Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment.create(\n          errorContext\n        );\n      }\n    }\n\n    const unusedPathParameterDefinitions = namedPathParamDefs\n      .map(({ paramName: name }) => name)\n      .filter((name) => !usedPathParams[name]);\n\n    if (__DEV__) {\n      if (unusedPathParameterDefinitions.length > 0) {\n        throw TypeRouteError.All_path_parameters_must_be_used_in_path_construction.create(\n          errorContext,\n          unusedPathParameterDefinitions\n        );\n      }\n    }\n\n    return pathDef;\n  });\n}\n\nfunction getParamId(parameterName: string) {\n  return \"${p.\" + parameterName + \"}\";\n}\n","import { ParamDefKind, ParamDefCollection } from \"./types\";\n\nexport function getParamDefsOfType<TParamType extends ParamDefKind>(\n  type: TParamType,\n  paramDefCollection: ParamDefCollection<ParamDefKind>\n) {\n  const filteredParamDefCollection: ParamDefCollection<TParamType> = {};\n\n  Object.keys(paramDefCollection).forEach((name) => {\n    const paramDef = paramDefCollection[name];\n    if (paramDef[\"~internal\"].kind === type) {\n      filteredParamDefCollection[name] =\n        paramDef as ParamDefCollection<TParamType>[string];\n    }\n  });\n\n  return filteredParamDefCollection;\n}\n","import {\n  RouterLocation,\n  UmbrellaParamDef,\n  UmbrellaParamDefCollection,\n  QueryStringSerializer,\n  PathDef,\n} from \"./types\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\ntype ParamWithContextCollection = Record<\n  string,\n  { valueSerializerId?: string; array: boolean; value: string | null }\n>;\n\nexport function createLocation({\n  paramCollection,\n  paramDefCollection,\n  arraySeparator,\n  queryStringSerializer,\n  pathDefs,\n  baseUrl,\n}: {\n  paramCollection: Record<string, unknown>;\n  paramDefCollection: UmbrellaParamDefCollection;\n  arraySeparator: string;\n  queryStringSerializer: QueryStringSerializer;\n  pathDefs: PathDef[];\n  baseUrl: string;\n}): RouterLocation {\n  const params = {\n    path: {} as ParamWithContextCollection,\n    query: {} as ParamWithContextCollection,\n    state: {} as ParamWithContextCollection,\n  };\n\n  for (const paramName in paramDefCollection) {\n    const paramValue = paramCollection[paramName];\n\n    if (paramValue === undefined) {\n      continue;\n    }\n\n    const paramDef = paramDefCollection[paramName];\n    const urlEncodeDefault =\n      paramDef[\"~internal\"].kind !== \"state\" && !paramDef[\"~internal\"].trailing;\n    const urlEncode =\n      paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault;\n\n    let value: string | null;\n\n    if (paramDef[\"~internal\"].array) {\n      if (!Array.isArray(paramValue)) {\n        if (__DEV__) {\n          throw TypeRouteError.Expected_type_does_not_match_actual_type.create({\n            context: \"routes[routeName](...)\",\n            actualType: typeOf(paramValue),\n            expectedType: \"array\",\n            value: paramValue,\n            valueName: paramName,\n          });\n        }\n      }\n\n      value =\n        (paramValue as unknown[]).length === 0\n          ? null\n          : (paramValue as unknown[])\n              .map((part) => stringify(paramDef, part, urlEncode))\n              .join(arraySeparator);\n    } else {\n      value = stringify(paramDef, paramValue, urlEncode);\n    }\n\n    params[paramDef[\"~internal\"].kind][paramName] = {\n      valueSerializerId: paramDef[\"~internal\"].valueSerializer.id,\n      array: paramDef[\"~internal\"].array,\n      value,\n    };\n  }\n\n  const path =\n    \"/\" +\n    pathDefs[0]\n      .filter(({ namedParamDef }) => {\n        return !(\n          namedParamDef?.[\"~internal\"].optional &&\n          params.path[namedParamDef.paramName] === undefined\n        );\n      })\n      .map(({ namedParamDef, leading, trailing }) => {\n        const rawParam = namedParamDef\n          ? params.path[namedParamDef.paramName].value\n          : \"\";\n        return leading + rawParam + trailing;\n      })\n      .join(\"/\");\n\n  const hasQueryParams = Object.keys(params.query).length > 0;\n\n  const query = hasQueryParams\n    ? queryStringSerializer.stringify(params.query)\n    : undefined;\n\n  if (__DEV__) {\n    if (hasQueryParams) {\n      assert(\"query\", [assert.type(\"string\", \"query\", query)]);\n    }\n  }\n\n  const state =\n    Object.keys(params.state).length === 0\n      ? undefined\n      : Object.keys(params.state).reduce(\n          (state, key) => ({\n            ...state,\n            [key]: params.state[key].value,\n          }),\n          {}\n        );\n\n  return {\n    fullPath: (baseUrl === \"/\" ? \"\" : baseUrl) + path,\n    path,\n    query,\n    state,\n  };\n}\n\nfunction stringify(\n  paramDef: UmbrellaParamDef,\n  value: unknown,\n  urlEncode: boolean\n) {\n  const result = paramDef[\"~internal\"].valueSerializer.stringify(value);\n\n  if (__DEV__) {\n    assert(\"[ValueSerializer].stringify\", [\n      assert.type(\"string\", \"result\", result),\n    ]);\n  }\n\n  return urlEncode ? encodeURIComponent(result) : result;\n}\n","export const noMatch = { __noMatch: true } as const;\n","export const stringUtils = { startsWith, endsWith, splitFirst };\n\nfunction startsWith(value: string, start: string) {\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== value[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction endsWith(value: string, end: string) {\n  for (let i = 1; i <= end.length; i++) {\n    if (end[end.length - i] !== value[value.length - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction splitFirst(value: string, split: string) {\n  const [first, ...rest] = value.split(split);\n  return [first, rest.join(split)] as const;\n}\n","import { noMatch } from \"./noMatch\";\nimport { PathDef } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { endsWith, startsWith } = stringUtils;\n\nexport function getPathMatch({\n  path,\n  pathDefs,\n  arraySeparator,\n}: {\n  path: string;\n  pathDefs: PathDef[];\n  arraySeparator: string;\n}) {\n  for (let index = 0; index < pathDefs.length; index++) {\n    const result = match(pathDefs[index]);\n    if (result !== false) {\n      return { ...result, primaryPath: index === 0 };\n    }\n  }\n\n  return false;\n\n  function match(pathDef: PathDef) {\n    const params: Record<string, unknown> = {};\n\n    if (path === \"/\" && pathDef.length === 0) {\n      return { params, numExtraneousParams: 0 };\n    }\n\n    const pathHasTrailingSlash = path.length > 1 && endsWith(path, \"/\");\n\n    if (pathHasTrailingSlash) {\n      path = path.slice(0, path.length - 1);\n    }\n\n    const pathSegmentList = path.split(\"/\").slice(1);\n\n    for (\n      let segmentIndex = 0;\n      segmentIndex < Math.max(pathDef.length, pathSegmentList.length);\n      segmentIndex++\n    ) {\n      const pathSegmentDef =\n        segmentIndex >= pathDef.length ? null : pathDef[segmentIndex];\n      let pathSegment =\n        segmentIndex >= pathSegmentList.length\n          ? null\n          : pathSegmentList[segmentIndex];\n\n      if (pathSegmentDef === null) {\n        return false;\n      }\n\n      const numRemainingPathSegmentDefs = pathDef.length - 1 - segmentIndex;\n\n      if (pathSegment === null) {\n        if (\n          numRemainingPathSegmentDefs !== 0 ||\n          !pathSegmentDef.namedParamDef?.[\"~internal\"].optional\n        ) {\n          return false;\n        }\n\n        break;\n      }\n\n      if (pathSegmentDef.namedParamDef?.[\"~internal\"].trailing) {\n        pathSegment = pathSegmentList.slice(segmentIndex).join(\"/\");\n      }\n\n      if (!startsWith(pathSegment, pathSegmentDef.leading)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeading = pathSegment.slice(\n        pathSegmentDef.leading.length\n      );\n\n      if (!endsWith(pathSegmentMinusLeading, pathSegmentDef.trailing)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeadingAndTrailing = pathSegmentMinusLeading.slice(\n        0,\n        pathSegmentMinusLeading.length - pathSegmentDef.trailing.length\n      );\n\n      if (!pathSegmentDef.namedParamDef) {\n        if (pathSegmentMinusLeadingAndTrailing === \"\") {\n          continue;\n        }\n\n        return false;\n      }\n\n      if (pathSegmentMinusLeadingAndTrailing === \"\") {\n        if (pathSegmentDef.namedParamDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n\n      const urlEncode =\n        pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.urlEncode ??\n        !pathSegmentDef.namedParamDef[\"~internal\"].trailing;\n\n      let value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].array) {\n        value = pathSegmentMinusLeadingAndTrailing\n          .split(arraySeparator)\n          .map((part) => {\n            return pathSegmentDef.namedParamDef?.[\n              \"~internal\"\n            ].valueSerializer.parse(\n              urlEncode ? decodeURIComponent(part) : part\n            );\n          });\n\n        if (value.some((part) => part === noMatch)) {\n          return false;\n        }\n      } else {\n        value = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.parse(\n          urlEncode\n            ? decodeURIComponent(pathSegmentMinusLeadingAndTrailing)\n            : pathSegmentMinusLeadingAndTrailing\n        );\n\n        if (value === noMatch) {\n          return false;\n        }\n      }\n\n      if (\n        pathSegmentDef.namedParamDef[\"~internal\"].trailing &&\n        pathHasTrailingSlash &&\n        pathSegmentDef.trailing === \"\"\n      ) {\n        value = `${value}/`;\n      }\n\n      params[pathSegmentDef.namedParamDef.paramName] = value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing) {\n        break;\n      }\n    }\n\n    return { params, numExtraneousParams: 0 };\n  }\n}\n","import { UmbrellaParamDefCollection } from \"./types\";\nimport { noMatch } from \"./noMatch\";\n\nexport function getObjectMatch({\n  object,\n  paramDefs,\n  urlEncodeDefault,\n  arraySeparator,\n}: {\n  object: Record<string, string | null>;\n  paramDefs: UmbrellaParamDefCollection;\n  urlEncodeDefault: boolean;\n  arraySeparator: string;\n}) {\n  const params: Record<string, unknown> = {};\n\n  const namedParamDefs = Object.keys(paramDefs).map((name) => {\n    return { name, ...paramDefs[name] };\n  });\n\n  const extraneousParams = { ...object };\n\n  for (const paramDef of namedParamDefs) {\n    let raw = object[paramDef.name];\n    delete extraneousParams[paramDef.name];\n\n    if (raw === undefined) {\n      if (paramDef[\"~internal\"].optional) {\n        continue;\n      }\n\n      return false;\n    }\n\n    let value;\n\n    if (raw === null) {\n      if (paramDef[\"~internal\"].array) {\n        value = [];\n      } else if (paramDef[\"~internal\"].optional) {\n        continue;\n      } else {\n        return false;\n      }\n    } else if (paramDef[\"~internal\"].array) {\n      value = raw.split(arraySeparator).map((part) => {\n        return paramDef[\"~internal\"].valueSerializer.parse(\n          paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n            ? decodeURIComponent(part)\n            : part\n        );\n      });\n\n      if (value.some((part) => part === noMatch)) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    } else {\n      value = paramDef[\"~internal\"].valueSerializer.parse(\n        paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n          ? decodeURIComponent(raw)\n          : raw\n      );\n\n      if (value === noMatch) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    }\n\n    params[paramDef.name] = value;\n  }\n\n  return { params, numExtraneousParams: Object.keys(extraneousParams).length };\n}\n","import {\n  RouterLocation,\n  PathDef,\n  QueryStringSerializer,\n  UmbrellaParamDefCollection,\n} from \"./types\";\nimport { getPathMatch } from \"./getPathMatch\";\nimport { getStateMatch } from \"./getStateMatch\";\nimport { getQueryMatch } from \"./getQueryMatch\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\n\nexport function createMatcher({\n  pathDefs,\n  params,\n}: {\n  pathDefs: PathDef[];\n  params: UmbrellaParamDefCollection;\n}) {\n  const queryParamDefCollection = getParamDefsOfType(\"query\", params);\n  const stateParamDefCollection = getParamDefsOfType(\"state\", params);\n\n  const defaultParams: Record<string, unknown> = {};\n\n  Object.keys(params).forEach((paramName) => {\n    const param = params[paramName];\n    if (param[\"~internal\"].default === undefined) {\n      return;\n    }\n    defaultParams[paramName] = param[\"~internal\"].default;\n  });\n\n  return ({\n    routerLocation,\n    arraySeparator,\n    queryStringSerializer,\n  }: {\n    routerLocation: RouterLocation;\n    queryStringSerializer: QueryStringSerializer;\n    arraySeparator: string;\n  }) => {\n    if (routerLocation.path === undefined) {\n      return false;\n    }\n\n    const pathMatch = getPathMatch({\n      path: routerLocation.path,\n      pathDefs,\n      arraySeparator,\n    });\n\n    if (pathMatch === false) {\n      return false;\n    }\n\n    const queryMatch = getQueryMatch(\n      routerLocation.query,\n      queryParamDefCollection,\n      queryStringSerializer,\n      arraySeparator\n    );\n    if (queryMatch === false) {\n      return false;\n    }\n\n    const stateMatch = getStateMatch(\n      routerLocation.state,\n      stateParamDefCollection,\n      arraySeparator\n    );\n    if (stateMatch === false) {\n      return false;\n    }\n\n    return {\n      primaryPath: pathMatch.primaryPath,\n      params: {\n        ...defaultParams,\n        ...pathMatch.params,\n        ...queryMatch.params,\n        ...stateMatch.params,\n      },\n      numExtraneousParams:\n        pathMatch.numExtraneousParams +\n        queryMatch.numExtraneousParams +\n        stateMatch.numExtraneousParams,\n    };\n  };\n}\n","import { getObjectMatch } from \"./getObjectMatch\";\nimport { ParamDefCollection, QueryStringSerializer } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function getQueryMatch(\n  query: string | undefined,\n  paramDefs: ParamDefCollection<\"query\">,\n  queryStringSerializer: QueryStringSerializer,\n  arraySeparator: string\n) {\n  let object: Record<string, string | null> = {};\n\n  if (query) {\n    object = queryStringSerializer.parse(query);\n\n    if (__DEV__) {\n      assert(\"[QueryStringSerializer].parse\", [\n        assert.collectionOfType(\n          [\"string\", \"null\"],\n          \"parsedQueryString\",\n          object\n        ),\n      ]);\n    }\n  }\n\n  return getObjectMatch({\n    object,\n    paramDefs,\n    urlEncodeDefault: true,\n    arraySeparator,\n  });\n}\n","import { ParamDefCollection } from \"./types\";\nimport { getObjectMatch } from \"./getObjectMatch\";\n\nexport function getStateMatch(\n  state: Record<string, string> | undefined,\n  paramDefs: ParamDefCollection<\"state\">,\n  arraySeparator: string\n) {\n  return getObjectMatch({\n    object: state ?? {},\n    paramDefs,\n    urlEncodeDefault: false,\n    arraySeparator,\n  });\n}\n","import { ClickEvent } from \"./types\";\n\nexport function preventDefaultLinkClickBehavior(event: any = {}) {\n  const e = event as ClickEvent;\n  const isModifiedEvent = !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n\n  const isSelfTarget =\n    !e.target || !e.target.target || e.target.target === \"_self\";\n\n  if (\n    isSelfTarget && // Ignore everything but links with target self\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !isModifiedEvent // ignore clicks with modifier keys\n  ) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n","import { UmbrellaRoute, RouterLocation, RouterContext } from \"./types\";\nimport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function buildRoute({\n  routeName,\n  params,\n  location,\n  routerContext,\n}: {\n  routeName: string | false;\n  params: Record<string, unknown>;\n  location: RouterLocation;\n  routerContext: RouterContext;\n}): UmbrellaRoute {\n  const { navigate, history } = routerContext;\n\n  let href = history.createHref({\n    pathname: routeName === false ? location.fullPath : location.path,\n    search: location.query ? \"?\" + location.query : \"\",\n  });\n\n  if (startsWith(href, \"#\")) {\n    href = \"/\" + href;\n  }\n\n  if (routeName !== false && routerContext.baseUrl !== \"/\") {\n    href = routerContext.baseUrl + href;\n  }\n\n  const route: UmbrellaRoute = {\n    name: routeName,\n    params,\n    href,\n    link: {\n      href,\n      onClick: (event) => {\n        if (preventDefaultLinkClickBehavior(event)) {\n          return route.push();\n        }\n      },\n    },\n    action: null,\n    push: () => navigate({ ...route, action: \"push\" }, true),\n    replace: () => navigate({ ...route, action: \"replace\" }, true),\n  };\n\n  return route;\n}\n","import { UmbrellaRouteDef, UmbrellaRouteBuilder, RouterContext } from \"./types\";\nimport { buildPathDefs } from \"./buildPathDefs\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\nimport { createLocation } from \"./createLocation\";\nimport { createMatcher } from \"./createMatcher\";\nimport { assert } from \"./assert\";\nimport { buildRoute } from \"./buildRoute\";\nimport { TypeRouteError } from \"./TypeRouteError\";\n\nexport function createRouteBuilder(\n  routeName: string,\n  routeDef: UmbrellaRouteDef,\n  getRouterContext: () => RouterContext\n): UmbrellaRouteBuilder {\n  const pathDefs = buildPathDefs(\n    routeName,\n    getParamDefsOfType(\"path\", routeDef[\"~internal\"].params),\n    routeDef[\"~internal\"].path\n  );\n\n  const build: UmbrellaRouteBuilder = function (\n    params: Record<string, unknown> = {}\n  ) {\n    if (__DEV__) {\n      assert(`routes.${routeName}`, [\n        assert.numArgs([].slice.call(arguments), 0, 1),\n        assert.type(\"object\", \"params\", params),\n      ]);\n\n      for (const paramKey in params) {\n        if (!(paramKey in routeDef[\"~internal\"].params)) {\n          throw TypeRouteError.Encountered_unexpected_parameter_when_building_route.create(\n            {\n              routeName,\n              unexpectedParameterName: paramKey,\n              allowedParameterNames: Object.keys(routeDef[\"~internal\"].params),\n            }\n          );\n        }\n      }\n\n      for (const paramKey in routeDef[\"~internal\"].params) {\n        const value = params[paramKey];\n        const paramDef = routeDef[\"~internal\"].params[paramKey][\"~internal\"];\n\n        if (value === undefined) {\n          if (!paramDef.optional) {\n            throw TypeRouteError.Missing_required_parameter_when_building_route.create(\n              {\n                routeName,\n                missingParameterName: paramKey,\n              }\n            );\n          }\n\n          continue;\n        }\n      }\n    }\n\n    const routerContext = getRouterContext();\n\n    const { arraySeparator, queryStringSerializer, baseUrl } = routerContext;\n\n    const paramsWithDefault = { ...params };\n\n    Object.keys(routeDef[\"~internal\"].params).forEach((paramName) => {\n      const paramDef = routeDef[\"~internal\"].params[paramName];\n\n      if (\n        paramsWithDefault[paramName] === undefined &&\n        paramDef[\"~internal\"].default !== undefined\n      ) {\n        paramsWithDefault[paramName] = paramDef[\"~internal\"].default;\n      }\n    });\n\n    const location = createLocation({\n      paramCollection: params,\n      paramDefCollection: routeDef[\"~internal\"].params,\n      arraySeparator,\n      queryStringSerializer,\n      pathDefs,\n      baseUrl,\n    });\n\n    return buildRoute({\n      routeName,\n      params: paramsWithDefault,\n      location,\n      routerContext,\n    }) as any;\n  };\n\n  Object.defineProperty(build, \"name\", { value: routeName });\n\n  build[\"~internal\"] = {\n    type: \"RouteBuilder\",\n    match: createMatcher({\n      pathDefs,\n      params: routeDef[\"~internal\"].params,\n    }) as any,\n    pathDefs,\n    Route: null as any,\n  };\n\n  return build;\n}\n","import { QueryStringSerializer, QueryStringArrayFormat } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nexport function createQueryStringSerializer(\n  args: {\n    queryStringArrayFormat?: QueryStringArrayFormat;\n    arraySeparator?: string;\n  } = {}\n): QueryStringSerializer {\n  const queryStringArrayFormat =\n    args.queryStringArrayFormat ?? \"singleKeyWithBracket\";\n  const arraySeparator = args.arraySeparator ?? \",\";\n\n  const multiKey =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"multiKeyWithBracket\";\n\n  const arrayKeySuffix =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"singleKey\"\n      ? \"\"\n      : \"[]\";\n\n  return {\n    parse: (raw) => {\n      const queryParams: Record<string, string | null> = {};\n\n      for (const part of raw.split(\"&\")) {\n        const [rawParamName, rawParamValue, ...rest] = part.split(\"=\");\n\n        if (rawParamName === undefined || rest.length > 0) {\n          continue;\n        }\n\n        const key = decodeURIComponent(\n          stringUtils.endsWith(rawParamName, arrayKeySuffix)\n            ? rawParamName.slice(0, rawParamName.length - arrayKeySuffix.length)\n            : rawParamName\n        );\n\n        if (rawParamValue === undefined) {\n          queryParams[key] = null;\n        } else if (queryParams[key] && multiKey) {\n          queryParams[key] += `${arraySeparator}${rawParamValue}`;\n        } else {\n          queryParams[key] = rawParamValue;\n        }\n      }\n\n      return queryParams;\n    },\n\n    stringify: (queryParams) => {\n      return Object.keys(queryParams)\n        .map((name) => {\n          const encodedName = encodeURIComponent(name);\n          const key = queryParams[name].array\n            ? `${encodedName}${arrayKeySuffix}`\n            : encodedName;\n          const value = queryParams[name].value;\n\n          if (value === null) {\n            return key;\n          }\n\n          if (queryParams[name].array && multiKey) {\n            const valueParts = value.split(arraySeparator);\n            return valueParts.map((part) => `${key}=${part}`).join(\"&\");\n          }\n\n          return `${key}=${value}`;\n        })\n        .join(\"&\");\n    },\n  };\n}\n","import { RouterLocation, UmbrellaRoute, Match, RouterContext } from \"./types\";\nimport { buildRoute } from \"./buildRoute\";\n\nexport function getMatchingRoute(\n  location: RouterLocation,\n  routerContext: RouterContext\n): { route: UmbrellaRoute; primaryPath: boolean } {\n  const { getRoutes, queryStringSerializer, arraySeparator } = routerContext;\n\n  const routes = getRoutes();\n\n  let nonExactMatch: (Match & { routeName: string }) | false = false;\n\n  for (const routeName in routes) {\n    const match = routes[routeName][\"~internal\"].match({\n      routerLocation: location,\n      queryStringSerializer,\n      arraySeparator,\n    });\n\n    if (match === false) {\n      continue;\n    }\n\n    if (match.numExtraneousParams === 0) {\n      return {\n        route: routes[routeName](match.params),\n        primaryPath: match.primaryPath,\n      };\n    }\n\n    if (\n      nonExactMatch === false ||\n      match.numExtraneousParams < nonExactMatch.numExtraneousParams\n    ) {\n      nonExactMatch = { ...match, routeName };\n    }\n  }\n\n  if (nonExactMatch) {\n    return {\n      route: routes[nonExactMatch.routeName](nonExactMatch.params),\n      primaryPath: nonExactMatch.primaryPath,\n    };\n  }\n\n  return {\n    route: buildRoute({\n      routeName: false,\n      params: {},\n      location,\n      routerContext,\n    }),\n    primaryPath: true,\n  };\n}\n","import { RouterLocation } from \"./types\";\nimport { Location as HistoryLocation } from \"history\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function convertToRouterLocationFromHistoryLocation(\n  rawLocation: Pick<HistoryLocation, \"pathname\" | \"search\" | \"state\">,\n  baseUrl: string\n): RouterLocation {\n  return {\n    fullPath: rawLocation.pathname,\n    path: startsWith(rawLocation.pathname, baseUrl)\n      ? baseUrl !== \"/\"\n        ? rawLocation.pathname.replace(baseUrl, \"\")\n        : rawLocation.pathname\n      : undefined,\n    query: rawLocation.search\n      ? startsWith(rawLocation.search, \"?\")\n        ? rawLocation.search.slice(1)\n        : rawLocation.search\n      : undefined,\n    state:\n      typeof rawLocation.state === \"object\" && rawLocation.state !== null\n        ? (rawLocation.state as { state?: Record<string, string> }).state\n        : undefined,\n  };\n}\n","import { RouterContext } from \"./types\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { splitFirst } = stringUtils;\n\nexport function getRouteByHref(\n  href: string,\n  state: any,\n  routerContext: RouterContext\n) {\n  const [pathname, search] = splitFirst(href, \"?\");\n\n  const location = convertToRouterLocationFromHistoryLocation(\n    {\n      pathname,\n      search,\n      state,\n    },\n    routerContext.baseUrl\n  );\n\n  return getMatchingRoute(location, routerContext);\n}\n","import { UmbrellaNavigationHandler } from \"./types\";\n\nexport function createNavigationHandlerManager({\n  startListening,\n  stopListening,\n}: {\n  startListening: () => void;\n  stopListening: () => void;\n}) {\n  const handlerIdList: {\n    handler: UmbrellaNavigationHandler;\n    id: number;\n  }[] = [];\n  let idCounter = 0;\n\n  return { add, getHandlers };\n\n  function getHandlers() {\n    return handlerIdList.map(({ handler }) => handler);\n  }\n\n  function add(handler: UmbrellaNavigationHandler) {\n    const id = idCounter++;\n    handlerIdList.push({ id, handler });\n\n    if (handlerIdList.length === 1) {\n      startListening();\n    }\n\n    return remove;\n\n    function remove() {\n      const index = handlerIdList.map(({ id }) => id).indexOf(id);\n      if (index >= 0) {\n        handlerIdList.splice(index, 1);\n        if (handlerIdList.length === 0) {\n          stopListening();\n        }\n      }\n    }\n  }\n}\n","import { UmbrellaRoute } from \"./types\";\n\nexport function attemptScrollToTop(\n  route: UmbrellaRoute,\n  scrollToTop: boolean | undefined\n) {\n  if (\n    route.action === \"push\" &&\n    typeof window === \"object\" &&\n    window !== null &&\n    typeof window.scroll === \"function\" &&\n    scrollToTop !== false &&\n    typeof navigator === \"object\" &&\n    navigator !== null &&\n    typeof navigator.userAgent === \"string\" &&\n    !(\n      navigator.userAgent.indexOf(\"Node.js\") > 0 ||\n      navigator.userAgent.indexOf(\"jsdom\") > 0\n    )\n  ) {\n    try {\n      window.scroll(0, 0);\n    } catch {}\n  }\n}\n","import { UmbrellaRoute, UmbrellaRouteDefCollection } from \"./types\";\n\nexport function serializeStateParams(\n  route: UmbrellaRoute,\n  routeDefs: UmbrellaRouteDefCollection\n) {\n  const state: Record<string, string> = {};\n\n  if (route.name) {\n    const sortedParams = Object.keys(route.params).sort();\n    for (const paramName of sortedParams) {\n      const paramDef =\n        routeDefs[route.name][\"~internal\"].params[paramName][\"~internal\"];\n\n      if (paramDef.kind === \"state\") {\n        const value = route.params[paramName];\n        state[paramName] = paramDef.valueSerializer.stringify(value);\n      }\n    }\n  }\n\n  return state;\n}\n","import {\n  CoreRouter,\n  Action,\n  SessionOpts,\n  UmbrellaRouteBuilder,\n  UmbrellaCoreRouter,\n  UmbrellaRoute,\n  UmbrellaRouteDefCollection,\n  RouterContext,\n  UmbrellaBlocker,\n  RouterOpts,\n} from \"./types\";\nimport { createRouteBuilder } from \"./createRouteBuilder\";\nimport {\n  createBrowserHistory,\n  History,\n  createMemoryHistory,\n  createHashHistory,\n} from \"history\";\nimport { createQueryStringSerializer } from \"./createQueryStringSerializer\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getRouteByHref } from \"./getRouteByHref\";\nimport { createNavigationHandlerManager } from \"./createNavigationHandlerManager\";\nimport { stringUtils } from \"./stringUtils\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { serializeStateParams } from \"./serializeStateParams\";\n\nconst { startsWith, splitFirst } = stringUtils;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): CoreRouter<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaCoreRouter {\n  const { routeDefs, opts } = parseArgs(args);\n\n  const navigationHandlerManager = createNavigationHandlerManager({\n    startListening: () => {\n      unlisten = history.listen((update) => {\n        if (skipNextEnvironmentTriggeredNavigation) {\n          skipNextEnvironmentTriggeredNavigation = false;\n          return;\n        }\n\n        const location = convertToRouterLocationFromHistoryLocation(\n          update.location,\n          baseUrl\n        );\n        const action = update.action.toLowerCase() as Action;\n        const { route, primaryPath } = getMatchingRoute(\n          location,\n          getRouterContext()\n        );\n\n        handleNavigation({ ...route, action }, primaryPath);\n      });\n    },\n    stopListening: () => unlisten?.(),\n  });\n\n  const baseUrl = opts.baseUrl ?? \"/\";\n  const arraySeparator = opts.arrayFormat?.separator ?? \",\";\n  const queryStringSerializer =\n    opts.queryStringSerializer ??\n    createQueryStringSerializer({\n      queryStringArrayFormat: opts.arrayFormat?.queryString,\n      arraySeparator,\n    });\n\n  let history: History;\n  let unlisten: (() => void) | undefined;\n  let skipNextEnvironmentTriggeredNavigation = false;\n  let skipHandlingNextApplicationTriggeredNavigation = false;\n  let initialRoute: UmbrellaRoute | null = null;\n  let previousRoute: UmbrellaRoute | null = null;\n  let blockerCollection: UmbrellaBlocker[] = [];\n\n  applySessionOpts(opts.session);\n\n  const routes = createRouteBuilderCollection(getRouterContext);\n\n  const router: UmbrellaCoreRouter = {\n    routes,\n    session: {\n      push(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].push\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"push\" }, primaryPath);\n      },\n      replace(href, state) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].replace\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"replace\" }, primaryPath);\n      },\n      back(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].back\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(-amount);\n      },\n      forward(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].forward\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(amount);\n      },\n      getInitialRoute() {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].getInitialRoute\", [\n            assert.numArgs([].slice.call(arguments), 0),\n          ]);\n        }\n\n        if (!initialRoute) {\n          let result = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              history.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          if (!result.primaryPath) {\n            skipHandlingNextApplicationTriggeredNavigation = true;\n            result.route.replace();\n            result = getMatchingRoute(\n              convertToRouterLocationFromHistoryLocation(\n                history.location,\n                baseUrl\n              ),\n              getRouterContext()\n            );\n          }\n          initialRoute = result.route;\n        }\n\n        return initialRoute;\n      },\n      reset(session) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].reset\", [\n            assert.numArgs([].slice.call(arguments), 1),\n            assert.type(\"object\", \"session\", session),\n          ]);\n        }\n\n        return applySessionOpts(session);\n      },\n      block(blocker) {\n        blockerCollection.push(blocker);\n\n        const unblock = history.block((update) => {\n          const { route } = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              update.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          const action = update.action.toLowerCase() as Action;\n\n          blocker({ route: { ...route, action }, retry: update.retry });\n        });\n\n        return () => {\n          blockerCollection.splice(\n            blockerCollection.findIndex((item) => item === blocker),\n            1\n          );\n\n          unblock();\n        };\n      },\n      listen: (handler) => navigationHandlerManager.add(handler),\n    },\n  };\n\n  return router;\n\n  function applySessionOpts(\n    sessionOpts: SessionOpts = {\n      type:\n        typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n          ? \"browser\"\n          : \"memory\",\n    }\n  ) {\n    initialRoute = null;\n    if (sessionOpts.type === \"memory\") {\n      history = createMemoryHistory({\n        initialEntries: sessionOpts.initialEntries,\n        initialIndex: sessionOpts.initialIndex,\n      });\n    } else if (sessionOpts.type === \"hash\") {\n      history = createHashHistory({\n        window: sessionOpts.window,\n      });\n    } else {\n      history = createBrowserHistory({\n        window: sessionOpts.window,\n      });\n    }\n  }\n\n  function navigate(route: UmbrellaRoute, primaryPath: boolean) {\n    if (blockerCollection.length > 0) {\n      blockerCollection.forEach((blocker) => {\n        blocker({\n          route,\n          retry: () => {\n            route[route.action === \"push\" ? \"push\" : \"replace\"]();\n          },\n        });\n      });\n\n      return;\n    }\n\n    const state = serializeStateParams(route, routeDefs);\n\n    if (\n      previousRoute?.href === route.href &&\n      JSON.stringify(serializeStateParams(previousRoute, routeDefs)) ===\n        JSON.stringify(state)\n    ) {\n      return;\n    }\n\n    if (skipHandlingNextApplicationTriggeredNavigation) {\n      skipHandlingNextApplicationTriggeredNavigation = false;\n    } else {\n      handleNavigation(route, primaryPath);\n    }\n\n    skipNextEnvironmentTriggeredNavigation = true;\n\n    const [pathname, search] = splitFirst(route.href, \"?\");\n\n    history[route.action === \"replace\" ? \"replace\" : \"push\"](\n      {\n        pathname,\n        search: search ? `?${search}` : \"\",\n        hash: \"\",\n      },\n      state ? { state } : undefined\n    );\n  }\n\n  function handleNavigation(route: UmbrellaRoute, primaryPath: boolean) {\n    if (!primaryPath) {\n      route.replace();\n      return;\n    }\n\n    for (const handler of navigationHandlerManager.getHandlers()) {\n      handler(route);\n    }\n\n    attemptScrollToTop(route, opts.scrollToTop);\n\n    previousRoute = route;\n  }\n\n  function getRouterContext(): RouterContext {\n    return {\n      queryStringSerializer,\n      arraySeparator,\n      navigate,\n      history,\n      routeDefs,\n      getRoutes: () => routes,\n      baseUrl,\n    };\n  }\n}\n\nexport function parseArgs(args: any[]) {\n  const routeDefs: UmbrellaRouteDefCollection =\n    args.length === 1 ? args[0] : args[1];\n  const opts: RouterOpts = args.length === 1 ? {} : args[0];\n\n  if (__DEV__) {\n    assert(\"createRouter\", [\n      assert.numArgs(args, 1, 2),\n      assert.collectionOfType(\"RouteDef\", \"routeDefs\", routeDefs),\n      assert.type(\"object\", \"opts\", opts),\n    ]);\n\n    if (opts.arrayFormat?.queryString && opts.queryStringSerializer) {\n      throw TypeRouteError.Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided.create();\n    }\n\n    if (typeof opts.baseUrl === \"string\") {\n      if (!startsWith(opts.baseUrl, \"/\")) {\n        throw TypeRouteError.Base_url_must_start_with_a_forward_slash.create(\n          opts.baseUrl\n        );\n      }\n\n      if (\n        opts.baseUrl\n          .split(\"/\")\n          .some((part) => encodeURIComponent(part) !== part)\n      ) {\n        throw TypeRouteError.Base_url_must_not_contain_any_characters_that_must_be_url_encoded.create(\n          opts.baseUrl\n        );\n      }\n    }\n  }\n\n  return { routeDefs, opts };\n}\n\nfunction createRouteBuilderCollection(getRouterContext: () => RouterContext) {\n  const routes: Record<string, UmbrellaRouteBuilder> = {};\n  const { routeDefs } = getRouterContext();\n\n  for (const routeName in routeDefs) {\n    const routeDef = routeDefs[routeName];\n    routes[routeName] = createRouteBuilder(\n      routeName,\n      routeDef,\n      getRouterContext\n    );\n  }\n\n  return routes;\n}\n","import {\n  PathFn,\n  UmbrellaParamDefCollection,\n  RouteDef,\n  UmbrellaRouteDef,\n} from \"./types\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { assert } from \"./assert\";\nimport { asArray } from \"./asArray\";\n\nexport function defineRoute<TParamDefCollection>(\n  params: TParamDefCollection,\n  path: PathFn<TParamDefCollection>\n): RouteDef<TParamDefCollection>;\nexport function defineRoute(path: string | string[]): RouteDef<{}>;\nexport function defineRoute(...args: any[]): UmbrellaRouteDef {\n  assertDefineRouteOrExtendArgs(\"defineRoute\", args);\n\n  const parent = parseArgs(args);\n\n  const routeDef: UmbrellaRouteDef = {\n    \"~internal\": {\n      type: \"RouteDef\",\n      params: parent.params,\n      path: parent.path,\n    },\n    extend(...args: any[]) {\n      assertDefineRouteOrExtendArgs(\"extend\", args);\n\n      const { params, path } = parseArgs(args);\n\n      const parentParamNames = Object.keys(parent.params);\n      const extensionParamNames = Object.keys(params);\n\n      const duplicateParamNames = parentParamNames.filter(\n        (name) => extensionParamNames.indexOf(name) >= 0\n      );\n\n      if (__DEV__) {\n        if (duplicateParamNames.length > 0) {\n          throw TypeRouteError.Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names.create(\n            duplicateParamNames\n          );\n        }\n      }\n\n      return defineRoute(\n        {\n          ...params,\n          ...parent.params,\n        },\n        (x) => {\n          const parentPathArray = asArray(\n            parent.path(filter(parentParamNames))\n          );\n          const childPathArray = asArray(path(filter(extensionParamNames)));\n\n          return ([] as string[]).concat(\n            ...parentPathArray.map((parentPath) =>\n              childPathArray.map((childPath) => {\n                if (parentPath === \"/\") {\n                  return childPath;\n                }\n\n                return parentPath + (childPath === \"/\" ? \"\" : childPath);\n              })\n            )\n          );\n\n          function filter(allowedKeys: string[]) {\n            const filteredX: Record<string, string> = {};\n\n            allowedKeys.forEach((key) => {\n              filteredX[key] = (x as Record<string, string>)[key];\n            });\n\n            return filteredX;\n          }\n        }\n      );\n    },\n  };\n\n  return routeDef;\n}\n\nfunction assertDefineRouteOrExtendArgs(functionName: string, args: any[]) {\n  if (__DEV__) {\n    if (args.length === 1) {\n      if (Array.isArray(args[0])) {\n        assert(functionName, [assert.arrayOfType(\"string\", \"path\", args[0])]);\n      } else {\n        assert(functionName, [assert.type(\"string\", \"path\", args[0])]);\n      }\n    } else {\n      assert(functionName, [\n        assert.numArgs(args, 1, 2),\n        assert.collectionOfType(\"ParamDef\", \"params\", args[0]),\n        assert.type(\"function\", \"path\", args[1]),\n      ]);\n    }\n  }\n}\n\nfunction parseArgs(args: any[]): {\n  params: UmbrellaParamDefCollection;\n  path: PathFn<UmbrellaParamDefCollection>;\n} {\n  return args.length === 1\n    ? {\n        params: {},\n        path: () => args[0],\n      }\n    : {\n        params: args[0],\n        path: args[1],\n      };\n}\n","import { noMatch } from \"./noMatch\";\nimport { ValueSerializer, ParamDefKind, ParamDef, ParamValue } from \"./types\";\nimport { assert } from \"./assert\";\n\nconst boolean: ValueSerializer<boolean> = {\n  id: \"boolean\",\n  parse: (raw) => (raw === \"true\" ? true : raw === \"false\" ? false : noMatch),\n  stringify: (value) => (value ? \"true\" : \"false\"),\n};\n\nconst number: ValueSerializer<number> = {\n  id: \"number\",\n  parse: (raw) => {\n    if (!isNumeric(raw)) {\n      return noMatch;\n    }\n\n    return parseFloat(raw);\n  },\n  stringify: (value) => value.toString(),\n};\n\nfunction isNumeric(value: string) {\n  return !isNaN(parseFloat(value)) && /^-?\\d*\\.?\\d*$/.test(value);\n}\n\nconst string: ValueSerializer<string> = {\n  id: \"string\",\n  parse: (raw) => raw,\n  stringify: (value) => value,\n};\n\nconst json = <TValue = unknown>() => {\n  const valueSerializer: ValueSerializer<TValue> = {\n    id: \"json\",\n    parse: (raw) => {\n      let value: TValue;\n\n      try {\n        value = JSON.parse(raw);\n      } catch {\n        return noMatch;\n      }\n\n      return value;\n    },\n    stringify: (value) => JSON.stringify(value),\n  };\n\n  return valueSerializer;\n};\n\nexport const param = {\n  path: {\n    ...getParamDefKindSection(\"path\", false),\n    trailing: getParamDefKindSection(\"path\", true),\n  },\n  query: getParamDefKindSection(\"query\", false),\n  state: getParamDefKindSection(\"state\", false),\n};\n\nfunction getParamDefKindSection<\n  TKind extends ParamDefKind,\n  TTrailing extends boolean\n>(kind: TKind, trailing: TTrailing) {\n  return {\n    ...getParamDefOptionalitySection(false, false),\n    array: getParamDefOptionalitySection(false, true),\n    optional: {\n      ...getParamDefOptionalitySection(true, false),\n      array: getParamDefOptionalitySection(true, true),\n    },\n  };\n\n  function getParamDefOptionalitySection<\n    TOptional extends boolean,\n    TArray extends boolean\n  >(optional: TOptional, array: TArray) {\n    return {\n      string: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: string,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      number: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: number,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      boolean: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: boolean,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      ofType<TValue = unknown>(\n        valueSerializer: ValueSerializer<TValue> = json<TValue>()\n      ) {\n        if (__DEV__) {\n          assert(\"[ParamDef].ofType\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"object\", \"valueSerializer\", valueSerializer),\n          ]);\n        }\n\n        return getParamDef({\n          \"~internal\": {\n            type: \"ParamDef\",\n            array,\n            kind,\n            optional,\n            valueSerializer,\n            trailing,\n            default: undefined as never,\n          },\n        });\n      },\n    };\n  }\n\n  type GetParamDefResult<T extends ParamDef<TKind>> =\n    T[\"~internal\"][\"optional\"] extends true\n      ? {\n          [\"~internal\"]: T[\"~internal\"];\n          default(value: ParamValue<T>): {\n            [\"~internal\"]: {\n              type: \"ParamDef\";\n              kind: T[\"~internal\"][\"kind\"];\n              array: T[\"~internal\"][\"array\"];\n              valueSerializer: T[\"~internal\"][\"valueSerializer\"];\n              optional: T[\"~internal\"][\"optional\"];\n              default: ParamValue<T>;\n              trailing: T[\"~internal\"][\"trailing\"];\n            };\n          };\n        }\n      : T;\n\n  function getParamDef<T extends ParamDef<TKind>>({\n    \"~internal\": internal,\n  }: T): GetParamDefResult<T> {\n    if (!internal.optional) {\n      return { \"~internal\": internal } as any;\n    }\n\n    return {\n      \"~internal\": internal,\n      default(value: any) {\n        if (__DEV__) {\n          assert(\"[ParamDef].default\", [\n            assert.numArgs([].slice.call(arguments), 1),\n          ]);\n        }\n\n        return {\n          \"~internal\": { ...internal, default: value },\n        };\n      },\n    } as any;\n  }\n}\n","import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function createGroup<T extends any[]>(groupItems: T): RouteGroup<T> {\n  if (__DEV__) {\n    assert(\"createGroup\", [\n      assert.numArgs([].slice.call(arguments), 1),\n      assert.arrayOfType(\n        [\"RouteGroup\", \"RouteBuilder\"],\n        \"groupItems\",\n        groupItems\n      ),\n    ]);\n  }\n\n  const routeNames: Record<string, true> = {};\n\n  groupItems.forEach((item) => {\n    if (isRouteGroup(item)) {\n      item.routeNames.forEach((name) => {\n        routeNames[name] = true;\n      });\n    } else {\n      routeNames[item.name] = true;\n    }\n  });\n\n  return {\n    \"~internal\": {\n      type: \"RouteGroup\",\n      Route: null as any,\n    },\n    routeNames: Object.keys(routeNames),\n    has(route: UmbrellaRoute): route is UmbrellaRoute {\n      if (__DEV__) {\n        assert(\"[RouteGroup].has\", [\n          assert.numArgs([].slice.call(arguments), 1),\n          assert.type(\"object\", \"route\", route),\n        ]);\n      }\n\n      if (route.name === false) {\n        return false;\n      }\n\n      return !!routeNames[route.name];\n    },\n  };\n}\n\nfunction isRouteGroup(\n  value: RouteGroup | UmbrellaRouteBuilder\n): value is RouteGroup {\n  return !!(value as RouteGroup).routeNames;\n}\n"],"names":["asArray","value","Array","isArray","getParamId","parameterName","getParamDefsOfType","type","paramDefCollection","filteredParamDefCollection","Object","keys","forEach","name","paramDef","kind","stringify","urlEncode","result","valueSerializer","encodeURIComponent","noMatch","__noMatch","stringUtils","start","i","length","end","split","join","endsWith","startsWith","getObjectMatch","object","paramDefs","urlEncodeDefault","arraySeparator","params","namedParamDefs","map","extraneousParams","raw","undefined","optional","array","part","parse","decodeURIComponent","some","numExtraneousParams","createMatcher","pathDefs","queryParamDefCollection","stateParamDefCollection","defaultParams","paramName","param","routerLocation","queryStringSerializer","path","pathMatch","index","match","primaryPath","pathDef","pathHasTrailingSlash","slice","pathSegmentList","segmentIndex","pathSegmentDef","pathSegment","namedParamDef","_pathSegmentDef$named","_pathSegmentDef$named2","trailing","leading","pathSegmentMinusLeading","pathSegmentMinusLeadingAndTrailing","_pathSegmentDef$named4","Math","max","getPathMatch","queryMatch","query","getQueryMatch","stateMatch","state","getStateMatch","preventDefaultLinkClickBehavior","event","target","defaultPrevented","button","metaKey","altKey","ctrlKey","shiftKey","preventDefault","buildRoute","routeName","location","routerContext","navigate","href","history","createHref","pathname","fullPath","search","baseUrl","route","link","onClick","push","action","replace","createRouteBuilder","routeDef","getRouterContext","pathParamDefCollection","getRawPath","namedPathParamDefs","paramIdCollection","rawPath","rawPathSegments","usedPathParams","rawSegment","includedParamDef","indexOf","filter","build","paramsWithDefault","paramCollection","paramValue","valueSerializerId","id","reduce","key","createLocation","defineProperty","Route","createQueryStringSerializer","args","queryStringArrayFormat","multiKey","arrayKeySuffix","queryParams","rawParamName","rawParamValue","rest","encodedName","getMatchingRoute","routes","getRoutes","nonExactMatch","convertToRouterLocationFromHistoryLocation","rawLocation","splitFirst","getRouteByHref","createNavigationHandlerManager","startListening","stopListening","handlerIdList","idCounter","add","handler","splice","getHandlers","attemptScrollToTop","scrollToTop","window","scroll","navigator","userAgent","serializeStateParams","routeDefs","sort","parseArgs","opts","createRouteBuilderCollection","boolean","number","isNaN","parseFloat","test","toString","string","getParamDefKindSection","getParamDefOptionalitySection","getParamDef","ofType","JSON","internal","groupItems","routeNames","item","has","unlisten","navigationHandlerManager","listen","update","skipNextEnvironmentTriggeredNavigation","toLowerCase","handleNavigation","arrayFormat","_opts$arrayFormat","separator","_opts$arrayFormat2","queryString","skipHandlingNextApplicationTriggeredNavigation","initialRoute","previousRoute","blockerCollection","applySessionOpts","session","router","back","amount","go","forward","getInitialRoute","reset","block","blocker","unblock","retry","findIndex","sessionOpts","document","createMemoryHistory","initialEntries","initialIndex","createHashHistory","createBrowserHistory","hash","defineRoute","parent","extend","parentParamNames","extensionParamNames","x","parentPathArray","childPathArray","concat","parentPath","childPath","allowedKeys","filteredX"],"mappings":"qnCAAgBA,EAAWC,UAClBC,MAAMC,QAAQF,GAASA,EAAQ,CAACA,GC4OzC,SAASG,EAAWC,SACX,OAASA,EAAgB,aC5OlBC,EACdC,EACAC,OAEMC,EAA6D,UAEnEC,OAAOC,KAAKH,GAAoBI,SAAQ,SAACC,OACjCC,EAAWN,EAAmBK,GAChCC,EAAS,aAAaC,OAASR,IACjCE,EAA2BI,GACzBC,MAICL,ECkHT,SAASO,EACPF,EACAb,EACAgB,OAEMC,EAASJ,EAAS,aAAaK,gBAAgBH,UAAUf,UAQxDgB,EAAYG,mBAAmBF,GAAUA,MC/IrCG,EAAU,CAAEC,WAAW,GCAvBC,EAEb,SAAoBtB,EAAeuB,OAC5B,IAAIC,EAAI,EAAGA,EAAID,EAAME,OAAQD,OAC5BD,EAAMC,KAAOxB,EAAMwB,UACd,SAGJ,GARIF,EAWb,SAAkBtB,EAAe0B,OAC1B,IAAIF,EAAI,EAAGA,GAAKE,EAAID,OAAQD,OAC3BE,EAAIA,EAAID,OAASD,KAAOxB,EAAMA,EAAMyB,OAASD,UACxC,SAGJ,GAjBIF,EAoBb,SAAoBtB,EAAe2B,SACR3B,EAAM2B,MAAMA,SAC9B,iBAAaC,KAAKD,KClBnBE,EAAyBP,EAAfQ,EAAeR,WCDjBS,eACdC,IAAAA,OACAC,IAAAA,UACAC,IAAAA,iBACAC,IAAAA,eAOMC,EAAkC,GAElCC,EAAiB5B,OAAOC,KAAKuB,GAAWK,KAAI,SAAC1B,aACxCA,KAAAA,GAASqB,EAAUrB,OAGxB2B,OAAwBP,oBAEnBnB,UACL2B,EAAMR,EAAOnB,EAASD,gBACnB2B,EAAiB1B,EAASD,WAErB6B,IAARD,SACE3B,EAAS,aAAa6B,wBAInB,OAGL1C,YAEQ,OAARwC,EAAc,KACZ3B,EAAS,aAAa8B,MAEnB,OAAI9B,EAAS,aAAa6B,wBAGxB,GAJP1C,EAAQ,QAML,GAAIa,EAAS,aAAa8B,WAC/B3C,EAAQwC,EAAIb,MAAMQ,GAAgBG,KAAI,SAACM,gBAC9B/B,EAAS,aAAaK,gBAAgB2B,gBAC3ChC,EAAS,aAAaK,gBAAgBF,aAAakB,GAC/CY,mBAAmBF,GACnBA,OAIEG,MAAK,SAACH,UAASA,IAASxB,YAC5BP,EAAS,aAAa6B,wBAInB,OAEJ,WACL1C,EAAQa,EAAS,aAAaK,gBAAgB2B,gBAC5ChC,EAAS,aAAaK,gBAAgBF,aAAakB,GAC/CY,mBAAmBN,GACnBA,MAGQpB,SACRP,EAAS,aAAa6B,wBAInB,GAIXN,EAAOvB,EAASD,MAAQZ,OAtDHqC,kBAAgB,kEAyDhC,CAAED,OAAAA,EAAQY,oBAAqBvC,OAAOC,KAAK6B,GAAkBd,iBCpEtDwB,SACdC,IAAAA,SACAd,IAAAA,OAKMe,EAA0B9C,EAAmB,QAAS+B,GACtDgB,EAA0B/C,EAAmB,QAAS+B,GAEtDiB,EAAyC,UAE/C5C,OAAOC,KAAK0B,GAAQzB,SAAQ,SAAC2C,OACrBC,EAAQnB,EAAOkB,QACcb,IAA/Bc,EAAM,uBAGVF,EAAcC,GAAaC,EAAM,yBAG5B,gBACLC,IAAAA,eACArB,IAAAA,eACAsB,IAAAA,8BAM4BhB,IAAxBe,EAAeE,YACV,MAGHC,sBFrCRD,IAAAA,KACAR,IAAAA,SACAf,IAAAA,eAMSyB,EAAQ,EAAGA,EAAQV,EAASzB,OAAQmC,IAAS,KAC9C3C,EAAS4C,EAAMX,EAASU,QACf,IAAX3C,cACUA,GAAQ6C,YAAuB,IAAVF,WAI9B,WAEEC,EAAME,OACP3B,EAAkC,MAE3B,MAATsB,GAAmC,IAAnBK,EAAQtC,aACnB,CAAEW,OAAAA,EAAQY,oBAAqB,OAGlCgB,EAAuBN,EAAKjC,OAAS,GAAKI,EAAS6B,EAAM,KAE3DM,IACFN,EAAOA,EAAKO,MAAM,EAAGP,EAAKjC,OAAS,YAG/ByC,EAAkBR,EAAK/B,MAAM,KAAKsC,MAAM,cAGxCE,aAIEC,EACJD,GAAgBJ,EAAQtC,OAAS,KAAOsC,EAAQI,GAC9CE,EACFF,GAAgBD,EAAgBzC,OAC5B,KACAyC,EAAgBC,MAEC,OAAnBC,YACK,MAKW,OAAhBC,SAEgC,GAJAN,EAAQtC,OAAS,EAAI0C,YAKpDC,EAAeE,gBAAfC,EAA+B,aAAa7B,qBAEtC,eAMP0B,EAAeE,gBAAfE,EAA+B,aAAaC,WAC9CJ,EAAcH,EAAgBD,MAAME,GAAcvC,KAAK,OAGpDE,EAAWuC,EAAaD,EAAeM,mBACnC,OAGHC,EAA0BN,EAAYJ,MAC1CG,EAAeM,QAAQjD,YAGpBI,EAAS8C,EAAyBP,EAAeK,oBAC7C,OAGHG,EAAqCD,EAAwBV,MACjE,EACAU,EAAwBlD,OAAS2C,EAAeK,SAAShD,YAGtD2C,EAAeE,oBACyB,KAAvCM,iBAIG,MAGkC,KAAvCA,SACER,EAAeE,cAAc,aAAa5B,wBAIvC,OAGH1B,WACJoD,EAAeE,cAAc,aAAapD,gBAAgBF,cACzDoD,EAAeE,cAAc,aAAaG,SAEzCzE,YAEAoE,EAAeE,cAAc,aAAa3B,WAC5C3C,EAAQ4E,EACLjD,MAAMQ,GACNG,KAAI,SAACM,yBACGwB,EAAeE,sBAAfO,EACL,aACA3D,gBAAgB2B,MAChB7B,EAAY8B,mBAAmBF,GAAQA,OAInCG,MAAK,SAACH,UAASA,IAASxB,eACzB,YAGTpB,EAAQoE,EAAeE,cAAc,aAAapD,gBAAgB2B,MAChE7B,EACI8B,mBAAmB8B,GACnBA,MAGQxD,YACL,UAKTgD,EAAeE,cAAc,aAAaG,UAC1CT,GAC4B,KAA5BI,EAAeK,WAEfzE,QAGFoC,EAAOgC,EAAeE,cAAchB,WAAatD,EAE7CoE,EAAeE,cAAc,aAAaG,yBA3G1CN,EAAe,EACnBA,EAAeW,KAAKC,IAAIhB,EAAQtC,OAAQyC,EAAgBzC,QACxD0C,IACA,SAHIA,kBA4GF,6DAIG,CAAE/B,OAAAA,EAAQY,oBAAqB,IE5GpBgC,CAAa,CAC7BtB,KAAMF,EAAeE,KACrBR,SAAAA,EACAf,eAAAA,QAGgB,IAAdwB,SACK,MAGHsB,WCjDRC,EACAjD,EACAwB,EACAtB,OAEIH,EAAwC,UAExCkD,IACFlD,EAASyB,EAAsBZ,MAAMqC,IAahCnD,EAAe,CACpBC,OAAAA,EACAC,UAAAA,EACAC,kBAAkB,EAClBC,eAAAA,IDwBmBgD,CACjB3B,EAAe0B,MACf/B,EACAM,EACAtB,OAEiB,IAAf8C,SACK,MAGHG,WE5DRC,EACApD,EACAE,UAEOJ,EAAe,CACpBC,aAAQqD,EAAAA,EAAS,GACjBpD,UAAAA,EACAC,kBAAkB,EAClBC,eAAAA,IFoDmBmD,CACjB9B,EAAe6B,MACfjC,EACAjB,UAEiB,IAAfiD,GAIG,CACLtB,YAAaH,EAAUG,YACvB1B,YACKiB,EACAM,EAAUvB,OACV6C,EAAW7C,OACXgD,EAAWhD,QAEhBY,oBACEW,EAAUX,oBACViC,EAAWjC,oBACXoC,EAAWpC,+BGlFHuC,EAAgCC,mBAAAA,IAAAA,EAAa,MACjDA,EAILC,QAJKD,EAIQC,OAAOA,QAA8B,UAJ7CD,EAI2BC,OAAOA,QAJlCD,EAQLE,kBACU,IATLF,EASNG,QATMH,EACmBI,SADnBJ,EACgCK,QADhCL,EAC4CM,SAD5CN,EACyDO,WADzDP,GAAAA,EAYGQ,gBAZHR,EAaJQ,iBAGG,ICfX,IAAQlE,EAAeR,WAEP2E,SACdC,IAAAA,UACA9D,IAAAA,OACA+D,IAAAA,SACAC,IAAAA,cAOQC,EAAsBD,EAAtBC,SAEJC,EAF0BF,EAAZG,QAECC,WAAW,CAC5BC,UAAwB,IAAdP,EAAsBC,EAASO,SAAWP,EAASzC,KAC7DiD,OAAQR,EAASjB,MAAQ,IAAMiB,EAASjB,MAAQ,KAG9CpD,EAAWwE,EAAM,OACnBA,EAAO,IAAMA,IAGG,IAAdJ,GAAiD,MAA1BE,EAAcQ,UACvCN,EAAOF,EAAcQ,QAAUN,OAG3BO,EAAuB,CAC3BjG,KAAMsF,EACN9D,OAAAA,EACAkE,KAAAA,EACAQ,KAAM,CACJR,KAAAA,EACAS,QAAS,SAACvB,MACJD,EAAgCC,UAC3BqB,EAAMG,SAInBC,OAAQ,KACRD,KAAM,kBAAMX,OAAcQ,GAAOI,OAAQ,UAAU,IACnDC,QAAS,kBAAMb,OAAcQ,GAAOI,OAAQ,aAAa,YAGpDJ,WCxCOM,EACdjB,EACAkB,EACAC,OZEAC,EACAC,EAEMC,EAWAC,EYdAvE,GZANoE,EYEEjH,EAAmB,OAAQ+G,EAAS,aAAahF,QZDnDmF,EYEEH,EAAS,aAAa1D,KZAlB8D,EAAqB/G,OAAOC,KAAK4G,GAAwBhF,KAC7D,SAACgB,aAEGA,UAAAA,GACGgE,EAAuBhE,OAO1BmE,EAAuC,GAE7CD,EAAmB7G,SAAQ,gBAAG2C,IAAAA,UAe5BmE,EAAkBnE,GAAanD,EAAWmD,MAkBrCvD,EAfSwH,EAAWE,IAeHnF,KAAI,SAACoF,MAoBJ,IAAnBA,EAAQjG,aACH,aAWHkG,EAAkBD,EAAQ/F,MAAM,KAAKsC,MAAM,GAE3C2D,EAAuC,GACvC7D,EAAmB,OAEA4D,kBAAiB,WAA/BE,UASLC,EAAsD,SAEnCN,kBAAoB,KAAhC3G,UACLgH,EAAWE,QAAQ5H,EAAWU,EAASyC,aAAe,IAiBxDwE,EAAmBjH,EACnB+G,EAAe/G,EAASyC,YAAa,MAIrCwE,EAAkB,OACQD,EAAWlG,MACrCxB,EAAW2H,EAAiBxE,YA+B9BS,EAAQiD,KAAK,CACXtC,aACAD,cACAH,cAAewD,SAYjB/D,EAAQiD,KAAK,CACXtC,QAASmD,EACTpD,SAAU,GACVH,cAAe,cAmCkBkD,EACpClF,KAAI,qBAAGgB,aACP0E,QAAO,SAACpH,UAAUgH,EAAehH,MAW7BmD,MYrNHkE,EAA8B,SAClC7F,YAAAA,IAAAA,EAAkC,QAuC5BgE,EAAgBiB,IAEdlF,EAAmDiE,EAAnDjE,eAAgBsB,EAAmC2C,EAAnC3C,sBAAuBmD,EAAYR,EAAZQ,QAEzCsB,OAAyB9F,GAE/B3B,OAAOC,KAAK0G,EAAS,aAAahF,QAAQzB,SAAQ,SAAC2C,OAC3CzC,EAAWuG,EAAS,aAAahF,OAAOkB,QAGXb,IAAjCyF,EAAkB5E,SACgBb,IAAlC5B,EAAS,uBAETqH,EAAkB5E,GAAazC,EAAS,6BAItCsF,kBV5DRgC,IAAAA,gBACA5H,IAAAA,mBACA4B,IAAAA,eACAsB,IAAAA,sBACAP,IAAAA,SACA0D,IAAAA,QASMxE,EAAS,CACbsB,KAAM,GACNwB,MAAO,GACPG,MAAO,eAGE/B,SACH8E,EAAaD,EAAgB7E,WAEhBb,IAAf2F,uBAUApI,EANEa,EAAWN,EAAmB+C,GAG9BtC,WACJH,EAAS,aAAaK,gBAAgBF,aAFP,UAA/BH,EAAS,aAAaC,OAAqBD,EAAS,aAAa4D,SAmBjEzE,EAbEa,EAAS,aAAa8B,MAce,IAApCyF,EAAyB3G,OACtB,KACC2G,EACE9F,KAAI,SAACM,UAAS7B,EAAUF,EAAU+B,EAAM5B,MACxCY,KAAKO,GAENpB,EAAUF,EAAUuH,EAAYpH,GAG1CoB,EAAOvB,EAAS,aAAaC,MAAMwC,GAAa,CAC9C+E,kBAAmBxH,EAAS,aAAaK,gBAAgBoH,GACzD3F,MAAO9B,EAAS,aAAa8B,MAC7B3C,MAAAA,QAzCC,IAAMsD,KAAa/C,IAAb+C,OA6CLI,EACJ,IACAR,EAAS,GACN8E,QAAO,gBAAG1D,IAAAA,4BAEPA,GAAAA,EAAgB,aAAa5B,eACYD,IAAzCL,EAAOsB,KAAKY,EAAchB,eAG7BhB,KAAI,gBAAGgC,IAAAA,uBAAeI,SACJJ,EACblC,EAAOsB,KAAKY,EAAchB,WAAWtD,MACrC,MAH0ByE,YAM/B7C,KAAK,WAyBH,CACL8E,UAAuB,MAAZE,EAAkB,GAAKA,GAAWlD,EAC7CA,KAAAA,EACAwB,MA1BqBzE,OAAOC,KAAK0B,EAAO8C,OAAOzD,OAAS,EAGtDgC,EAAsB1C,UAAUqB,EAAO8C,YACvCzC,EAuBF4C,MAdqC,IAArC5E,OAAOC,KAAK0B,EAAOiD,OAAO5D,YACtBgB,EACAhC,OAAOC,KAAK0B,EAAOiD,OAAOkD,QACxB,SAAClD,EAAOmD,qBACHnD,UACFmD,GAAMpG,EAAOiD,MAAMmD,GAAKxI,YAE3B,KU1CWyI,CAAe,CAC9BN,gBAAiB/F,EACjB7B,mBAAoB6G,EAAS,aAAahF,OAC1CD,eAAAA,EACAsB,sBAAAA,EACAP,SAAAA,EACA0D,QAAAA,WAGKX,EAAW,CAChBC,UAAAA,EACA9D,OAAQ8F,EACR/B,SAAAA,EACAC,cAAAA,YAIJ3F,OAAOiI,eAAeT,EAAO,OAAQ,CAAEjI,MAAOkG,IAE9C+B,EAAM,aAAe,CACnB3H,KAAM,eACNuD,MAAOZ,EAAc,CACnBC,SAAAA,EACAd,OAAQgF,EAAS,aAAahF,SAEhCc,SAAAA,EACAyF,MAAO,MAGFV,WCvGOW,EACdC,oBAAAA,IAAAA,EAGI,QAEEC,WACJD,EAAKC,0BAA0B,uBAC3B3G,WAAiB0G,EAAK1G,kBAAkB,IAExC4G,EACuB,aAA3BD,GAC2B,wBAA3BA,EAEIE,EACuB,aAA3BF,GAC2B,cAA3BA,EACI,GACA,WAEC,CACLjG,MAAO,SAACL,aACAyG,EAA6C,OAEhCzG,EAAIb,MAAM,qBAAM,eACmBA,MAAM,KAAnDuH,OAAcC,OAAkBC,uBAElB3G,IAAjByG,GAA8BE,EAAK3H,OAAS,QAI1C+G,EAAM1F,mBACVxB,EAAqB4H,EAAcF,GAC/BE,EAAajF,MAAM,EAAGiF,EAAazH,OAASuH,EAAevH,QAC3DyH,QAGgBzG,IAAlB0G,EACFF,EAAYT,GAAO,KACVS,EAAYT,IAAQO,EAC7BE,EAAYT,OAAWrG,EAAiBgH,EAExCF,EAAYT,GAAOW,UAIhBF,GAGTlI,UAAW,SAACkI,UACHxI,OAAOC,KAAKuI,GAChB3G,KAAI,SAAC1B,OACEyI,EAAclI,mBAAmBP,GACjC4H,EAAMS,EAAYrI,GAAM+B,SACvB0G,EAAcL,EACjBK,EACErJ,EAAQiJ,EAAYrI,GAAMZ,aAElB,OAAVA,EACKwI,EAGLS,EAAYrI,GAAM+B,OAASoG,EACV/I,EAAM2B,MAAMQ,GACbG,KAAI,SAACM,UAAY4F,MAAO5F,KAAQhB,KAAK,KAG/C4G,MAAOxI,KAElB4B,KAAK,gBCrEE0H,EACdnD,EACAC,OAEmB3C,EAA0C2C,EAA1C3C,sBAAuBtB,EAAmBiE,EAAnBjE,eAEpCoH,GAASC,EAF8CpD,EAArDoD,aAIJC,GAAyD,MAExD,IAAMvD,KAAaqD,EAAQ,KACxB1F,EAAQ0F,EAAOrD,GAAW,aAAarC,MAAM,CACjDL,eAAgB2C,EAChB1C,sBAAAA,EACAtB,eAAAA,QAGY,IAAV0B,MAI8B,IAA9BA,EAAMb,0BACD,CACL6D,MAAO0C,EAAOrD,GAAWrC,EAAMzB,QAC/B0B,YAAaD,EAAMC,eAKH,IAAlB2F,GACA5F,EAAMb,oBAAsByG,EAAczG,uBAE1CyG,OAAqB5F,GAAOqC,UAAAA,aAI5BuD,EACK,CACL5C,MAAO0C,EAAOE,EAAcvD,WAAWuD,EAAcrH,QACrD0B,YAAa2F,EAAc3F,aAIxB,CACL+C,MAAOZ,EAAW,CAChBC,WAAW,EACX9D,OAAQ,GACR+D,SAAAA,EACAC,cAAAA,IAEFtC,aAAa,GCjDjB,IAAQhC,EAAeR,WAEPoI,EACdC,EACA/C,SAEO,CACLF,SAAUiD,EAAYlD,SACtB/C,KAAM5B,EAAW6H,EAAYlD,SAAUG,GACvB,MAAZA,EACE+C,EAAYlD,SAASS,QAAQN,EAAS,IACtC+C,EAAYlD,cACdhE,EACJyC,MAAOyE,EAAYhD,OACf7E,EAAW6H,EAAYhD,OAAQ,KAC7BgD,EAAYhD,OAAO1C,MAAM,GACzB0F,EAAYhD,YACdlE,EACJ4C,MAC+B,iBAAtBsE,EAAYtE,OAA4C,OAAtBsE,EAAYtE,MAChDsE,EAAYtE,MAA6CA,WAC1D5C,GCpBV,IAAQmH,EAAetI,EAEvB,SAAgBuI,EACdvD,EACAjB,EACAe,SAE2BwD,EAAWtD,EAAM,YAWrCgD,EATUI,EACf,CACEjD,cACAE,YACAtB,MAAAA,GAEFe,EAAcQ,SAGkBR,YCrBpB0D,SACdC,IAAAA,eACAC,IAAAA,cAKMC,EAGA,GACFC,EAAY,QAET,CAAEC,aAMIC,OACL9B,EAAK4B,WACXD,EAAcjD,KAAK,CAAEsB,GAAAA,EAAI8B,QAAAA,IAEI,IAAzBH,EAAcxI,QAChBsI,mBAMMnG,EAAQqG,EAAc3H,KAAI,qBAAGgG,MAAaP,QAAQO,GACpD1E,GAAS,IACXqG,EAAcI,OAAOzG,EAAO,GACC,IAAzBqG,EAAcxI,QAChBuI,OArBMM,8BAGLL,EAAc3H,KAAI,qBAAG8H,sBChBhBG,EACd1D,EACA2D,MAGmB,SAAjB3D,EAAMI,QACY,iBAAXwD,QACI,OAAXA,QACyB,mBAAlBA,OAAOC,SACE,IAAhBF,GACqB,iBAAdG,WACO,OAAdA,WAC+B,iBAAxBA,UAAUC,aAEfD,UAAUC,UAAU7C,QAAQ,WAAa,GACzC4C,UAAUC,UAAU7C,QAAQ,SAAW,OAIvC0C,OAAOC,OAAO,EAAG,GACjB,oBCpBUG,EACdhE,EACAiE,OAEMzF,EAAgC,MAElCwB,EAAMjG,mBACaH,OAAOC,KAAKmG,EAAMzE,QAAQ2I,uBACT,KAA3BzH,UACHzC,EACJiK,EAAUjE,EAAMjG,MAAM,aAAawB,OAAOkB,GAAW,aAEjC,UAAlBzC,EAASC,OAEXuE,EAAM/B,GAAazC,EAASK,gBAAgBH,UAD9B8F,EAAMzE,OAAOkB,YAM1B+B,MCSWuE,EAAetI,WA+RnB0J,EAAUnC,SAmCjB,CAAEiC,UAjCS,IAAhBjC,EAAKpH,OAAeoH,EAAK,GAAKA,EAAK,GAiCjBoC,KAhCqB,IAAhBpC,EAAKpH,OAAe,GAAKoH,EAAK,IAmCzD,SAASqC,EAA6B7D,OAC9BkC,EAA+C,GAC7CuB,EAAczD,IAAdyD,cAEH,IAAM5E,KAAa4E,EAEtBvB,EAAOrD,GAAaiB,EAClBjB,EAFe4E,EAAU5E,GAIzBmB,UAIGkC,ECxQT,SAASyB,EAAUnC,UAIM,IAAhBA,EAAKpH,OACR,CACEW,OAAQ,GACRsB,KAAM,kBAAMmF,EAAK,KAEnB,CACEzG,OAAQyG,EAAK,GACbnF,KAAMmF,EAAK,QC/GbsC,EAAoC,CACxC7C,GAAI,UACJzF,MAAO,SAACL,SAAiB,SAARA,GAAgC,UAARA,GAA0BpB,GACnEL,UAAW,SAACf,UAAWA,EAAQ,OAAS,UAGpCoL,EAAkC,CACtC9C,GAAI,SACJzF,MAAO,SAACL,UAUSxC,EATAwC,EAUT6I,MAAMC,WAAWtL,MAAW,gBAAgBuL,KAAKvL,GAT9CoB,EAGFkK,WAAW9I,GAKtB,IAAmBxC,GAHjBe,UAAW,SAACf,UAAUA,EAAMwL,aAOxBC,EAAkC,CACtCnD,GAAI,SACJzF,MAAO,SAACL,UAAQA,GAChBzB,UAAW,SAACf,UAAUA,IAuBXuD,EAAQ,CACnBG,UACKgI,EAAuB,QAAQ,IAClCjH,SAAUiH,EAAuB,QAAQ,KAE3CxG,MAAOwG,EAAuB,SAAS,GACvCrG,MAAOqG,EAAuB,SAAS,IAGzC,SAASA,EAGP5K,EAAa2D,eAERkH,GAA8B,GAAO,IACxChJ,MAAOgJ,GAA8B,GAAO,GAC5CjJ,cACKiJ,GAA8B,GAAM,IACvChJ,MAAOgJ,GAA8B,GAAM,gBAItCA,EAGPjJ,EAAqBC,SACd,CACL8I,OAAQG,EAAY,aACL,CACXtL,KAAM,WACNqC,MAAAA,EACA7B,KAAAA,EACA4B,SAAAA,EACAxB,gBAAiBuK,EACjBhH,SAAAA,eACShC,KAIb2I,OAAQQ,EAAY,aACL,CACXtL,KAAM,WACNqC,MAAAA,EACA7B,KAAAA,EACA4B,SAAAA,EACAxB,gBAAiBkK,EACjB3G,SAAAA,eACShC,aAIJmJ,EAAY,aACN,CACXtL,KAAM,WACNqC,MAAAA,EACA7B,KAAAA,EACA4B,SAAAA,EACAxB,gBAAiBiK,EACjB1G,SAAAA,eACShC,KAIboJ,gBACE3K,mBAAAA,IAAAA,EAnF2C,CAC/CoH,GAAI,OACJzF,MAAO,SAACL,OACFxC,MAGFA,EAAQ8L,KAAKjJ,MAAML,GACnB,gBACOpB,SAGFpB,GAETe,UAAW,SAACf,UAAU8L,KAAK/K,UAAUf,MA+E1B4L,EAAY,aACJ,CACXtL,KAAM,WACNqC,MAAAA,EACA7B,KAAAA,EACA4B,SAAAA,EACAxB,gBAAAA,EACAuD,SAAAA,eACShC,gBAyBVmJ,SACMG,IAAb,oBAEKA,EAASrJ,SAIP,aACQqJ,mBACL/L,SAOC,kBACa+L,WAAmB/L,OAblC,aAAe+L,iCC/JiBC,OAYrCC,EAAmC,UAEzCD,EAAWrL,SAAQ,SAACuL,GACDA,EAmCYD,WAlC3BC,EAAKD,WAAWtL,SAAQ,SAACC,GACvBqL,EAAWrL,IAAQ,KAGrBqL,EAAWC,EAAKtL,OAAQ,KAIrB,aACQ,CACXN,KAAM,aACNqI,MAAO,MAETsD,WAAYxL,OAAOC,KAAKuL,GACxBE,aAAItF,UAQiB,IAAfA,EAAMjG,QAIDqL,EAAWpF,EAAMjG,8BHJhC,gDAAgCiI,2BAAAA,sBAoC1BtC,EACA6F,IApCwBpB,EAAUnC,GAA9BiC,IAAAA,UAAWG,IAAAA,KAEboB,EAA2BvC,EAA+B,CAC9DC,eAAgB,WACdqC,EAAW7F,EAAQ+F,QAAO,SAACC,MACrBC,EACFA,GAAyC,WAIrCrG,EAAWuD,EACf6C,EAAOpG,SACPS,GAEIK,EAASsF,EAAOtF,OAAOwF,gBACEnD,EAC7BnD,EACAkB,KAFavD,IAAAA,YAKf4I,SALQ7F,OAKqBI,OAAAA,IAAUnD,QAG3CkG,cAAe,wBAAMoC,SAAAA,OAGjBxF,WAAUqE,EAAKrE,WAAW,IAC1BzE,oBAAiB8I,EAAK0B,oBAALC,EAAkBC,aAAa,IAChDpJ,WACJwH,EAAKxH,yBACLmF,EAA4B,CAC1BE,gCAAwBmC,EAAK0B,oBAALG,EAAkBC,YAC1C5K,eAAAA,IAKAqK,GAAyC,EACzCQ,GAAiD,EACjDC,EAAqC,KACrCC,EAAsC,KACtCC,EAAuC,GAE3CC,EAAiBnC,EAAKoC,aAEhB9D,EAAS2B,EAA6B7D,GAEtCiG,EAA6B,CACjC/D,OAAAA,EACA8D,QAAS,CACPrG,cAAKV,EAAMjB,SASsBwE,EAC7BvD,EACAjB,EACAgC,KAHavD,IAAAA,mBAMRuC,SANCQ,OAMoBI,OAAQ,SAAUnD,IAEhDoD,iBAAQZ,EAAMjB,SASmBwE,EAC7BvD,EACAjB,EACAgC,KAHavD,IAAAA,mBAMRuC,SANCQ,OAMoBI,OAAQ,YAAanD,IAEnDyJ,cAAKC,YAAAA,IAAAA,EAAS,GAQZjH,EAAQkH,IAAID,IAEdE,iBAAQF,YAAAA,IAAAA,EAAS,GAQfjH,EAAQkH,GAAGD,IAEbG,+BAOOV,EAAc,KACbhM,EAASqI,EACXI,EACEnD,EAAQJ,SACRS,GAEFS,KAGGpG,EAAO6C,cACVkJ,GAAiD,EACjD/L,EAAO4F,MAAMK,UACbjG,EAASqI,EACPI,EACEnD,EAAQJ,SACRS,GAEFS,MAGJ4F,EAAehM,EAAO4F,aAGjBoG,GAETW,eAAMP,UAQGD,EAAiBC,IAE1BQ,eAAMC,GACJX,EAAkBnG,KAAK8G,OAEjBC,EAAUxH,EAAQsH,OAAM,SAACtB,OACrB1F,EAAUyC,EAChBI,EACE6C,EAAOpG,SACPS,GAEFS,KALMR,MAQFI,EAASsF,EAAOtF,OAAOwF,cAE7BqB,EAAQ,CAAEjH,WAAYA,GAAOI,OAAAA,IAAU+G,MAAOzB,EAAOyB,kBAGhD,WACLb,EAAkB9C,OAChB8C,EAAkBc,WAAU,SAAC/B,UAASA,IAAS4B,KAC/C,GAGFC,MAGJzB,OAAQ,SAAClC,UAAYiC,EAAyBlC,IAAIC,aAI/CkD,WAEEF,EACPc,YAAAA,IAAAA,EAA2B,CACzB5N,KACoB,oBAAXmK,aAAqD,IAApBA,OAAO0D,SAC3C,UACA,WAGRlB,EAAe,KAEb1G,EADuB,WAArB2H,EAAY5N,KACJ8N,sBAAoB,CAC5BC,eAAgBH,EAAYG,eAC5BC,aAAcJ,EAAYI,eAEE,SAArBJ,EAAY5N,KACXiO,oBAAkB,CAC1B9D,OAAQyD,EAAYzD,SAGZ+D,uBAAqB,CAC7B/D,OAAQyD,EAAYzD,kBAKjBpE,EAASQ,EAAsB/C,YAClCqJ,EAAkB1L,OAAS,EAC7B0L,EAAkBxM,SAAQ,SAACmN,GACzBA,EAAQ,CACNjH,MAAAA,EACAmH,MAAO,WACLnH,EAAuB,SAAjBA,EAAMI,OAAoB,OAAS,4BAQ3C5B,EAAQwF,EAAqBhE,EAAOiE,gBAGxCoC,YAAe5G,QAASO,EAAMP,MAC9BwF,KAAK/K,UAAU8J,EAAqBqC,EAAepC,MACjDgB,KAAK/K,UAAUsE,IAKf2H,EACFA,GAAiD,EAEjDN,EAAiB7F,EAAO/C,GAG1B0I,GAAyC,QAEd5C,EAAW/C,EAAMP,KAAM,KAAjCK,OAEjBJ,EAAyB,YAAjBM,EAAMI,OAAuB,UAAY,QAC/C,CACER,cACAE,OAAQA,MAAaA,EAAW,GAChC8H,KAAM,IAERpJ,EAAQ,CAAEA,MAAAA,QAAU5C,cAIfiK,EAAiB7F,EAAsB/C,MACzCA,iBAKiBuI,EAAyB/B,+BAC7CF,WAAQvD,GAGV0D,EAAmB1D,EAAOoE,EAAKT,aAE/B0C,EAAgBrG,OAVdA,EAAMK,mBAaDG,UACA,CACL5D,sBAAAA,EACAtB,eAAAA,EACAkE,SAAAA,EACAE,QAAAA,EACAuE,UAAAA,EACAtB,UAAW,kBAAMD,GACjB3C,QAAAA,kCCzSU8H,+BAAe7F,2BAAAA,sBAGvB8F,EAAS3D,EAAUnC,GAEnBzB,EAA6B,aACpB,CACX9G,KAAM,WACN8B,OAAQuM,EAAOvM,OACfsB,KAAMiL,EAAOjL,MAEfkL,6CAAU/F,2BAAAA,wBAGiBmC,EAAUnC,GAA3BzG,IAAAA,OAAQsB,IAAAA,KAEVmL,EAAmBpO,OAAOC,KAAKiO,EAAOvM,QACtC0M,EAAsBrO,OAAOC,KAAK0B,UAEZyM,EAAiB7G,QAC3C,SAACpH,UAASkO,EAAoB/G,QAAQnH,IAAS,KAW1C8N,OAEAtM,EACAuM,EAAOvM,SAEZ,SAAC2M,SACOC,EAAkBjP,EACtB4O,EAAOjL,KAAKsE,EAAO6G,KAEfI,EAAiBlP,EAAQ2D,EAAKsE,EAAO8G,kBAEnBI,eACnBF,EAAgB1M,KAAI,SAAC6M,UACtBF,EAAe3M,KAAI,SAAC8M,SACC,MAAfD,EACKC,EAGFD,GAA4B,MAAdC,EAAoB,GAAKA,mBAK3CpH,EAAOqH,OACRC,EAAoC,UAE1CD,EAAY1O,SAAQ,SAAC6H,GACnB8G,EAAU9G,GAAQuG,EAA6BvG,MAG1C8G,eAOVlI"}